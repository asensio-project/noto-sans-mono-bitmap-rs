//! Pre-rasterized bitmap font from "Noto Sans Mono", an open font from Google. \
//! * Downloaded from: <https://fonts.google.com/noto/specimen/Noto+Sans+Mono>
//! * License: SIL Open Font License (OFL) <https://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=OFL>
//!
//! # TL;DR
//! * ✅ `no_std`, zero allocations
//! * ✅ most important symbols, numbers, and letters as pre-rasterized bitmap
//! * ✅ Noto Sans Mono font as base
//! * ✅ different sizes and font weights (light, normal, bold)
//! * ✅ nice anti-aliasing/smoothing and better looking than legacy bitmap fonts
//! * ✅ relevant font sizes, such as 14, 16, 24, 32, and 64px (as build time feature)
//!
//! If all Cargo features are available, this bitmap fonts supports `light`, `regular`,
//! and `bold`, but no `italic` style, because Noto Sans Mono doesn't have an italic
//! TTF file. The rasterization was done with the awesome [fontdue-Crate](https://crates.io/crates/fontdue).
//!
//! By default, all sizes and font styles/weights are included via the cargo feature `all`.
//! This can be restricted by only using features such as `regular` and `size_14`. Anyhow,
//! a test of mine showed, that including all features in a release build only increases the
//! file size by a few dozen kilobytes.
//!
//! The bitmap font includes the following unicode range:
//! - BASIC LATIN,
//! - LATIN 1 Supplement
//! - LATIN EXTENDED-A
//!
//! This means unicode symbols from `0 .. 0x17f`, hence letters and
//! and symbols from a QWERTZ/QWERTY keyboard plus symbols such as
//! Ö, Ä, and Ü. Control characters are not included.

#![no_std]
#![deny(
    clippy::all,
    clippy::cargo,
    clippy::nursery,
    // clippy::restriction,
    // clippy::pedantic
)]
// now allow a few rules which are denied by the above statement
// --> they are ridiculous and not necessary
#![allow(
    clippy::suboptimal_flops,
    clippy::redundant_pub_crate,
    clippy::fallible_impl_from
)]
#![deny(missing_debug_implementations)]
#![deny(rustdoc::all)]

// !!! THIS FILE GETS GENERATED BY THE "./codegen"-PROJECT IN THE SAME REPOSITORY. !!!

// %CODEGEN_LIB_MODULES%

/// Describes the relevant information for a rendered char of the bitmap font.
pub struct BitmapChar {
    /// The actual bitmap that is `height` * `width` big. Each bitmap value reaches
    /// from 0 to 255 and describes the intensity of this pixel.
    bitmap: &'static [&'static [u8]],
    /// Height of the bitmap box. The actual font size is slightly smaller.
    height: usize,
    /// The width of the bitmap char. It is guaranteed, that all chars
    /// of the same font width and bitmap height also have the same size.
    /// As you can naturally expect from a mono font.. :)
    width: usize,
}

impl BitmapChar {
    #[inline]
    pub const fn bitmap(&self) -> &'static [&'static [u8]] {
        self.bitmap
    }

    #[inline]
    pub const fn height(&self) -> usize {
        self.height
    }

    #[inline]
    pub const fn width(&self) -> usize {
        self.width
    }
}

/// Supported font weights.
///
/// The available variants depend on the selected Cargo build features.
#[derive(Debug, Copy, Clone)]
#[repr(usize)]
pub enum FontWeight {
// %CODEGEN_FONT_WEIGHT_VARIANTS%
}

impl FontWeight {
    /// Returns the numeric value of the enum variant.
    #[inline]
    pub const fn val(self) -> usize {
        self as _
    }
}

/// The height of the bitmap font. The font size will be a a few
/// percent less, because each bitmap letter contains vertical padding
/// for proper alignment of chars (i.e. ÄyA). The width of each bitmap
/// character will be also less than the height, because there is no
/// horizontal padding included.
///
/// The available variants depend on the selected Cargo build features.
#[derive(Debug, Clone, Copy)]
#[repr(usize)]
pub enum BitmapHeight {
// %CODEGEN_BITMAP_SIZE_ENUM_VARIANTS%
}

impl BitmapHeight {
    /// Returns the numeric value of the variant.
    #[inline]
    pub const fn val(self) -> usize {
        self as _
    }
}

/// Returns a [`BitmapChar`] for the given char, [`FontWeight`], and [`BitmapHeight`].
#[inline]
pub const fn get_bitmap(c: char, style: FontWeight, size: BitmapHeight) -> BitmapChar {
    let bitmap = match style {
// %CODEGEN_GET_BITMAP%
    };

    BitmapChar {
        bitmap,
        height: size.val(),
        width: get_bitmap_width(style, size)
    }
}

/// Returns the bitmap width for the given [`FontWeight`] and [`BitmapHeight`].
/// The width is a few percent smaller than the bitmap height, but constant
/// for each character of the pre rasterized bitmap font.
#[inline]
pub const fn get_bitmap_width(style: FontWeight, size: BitmapHeight) -> usize {
    match style {
// %CODEGEN_GET_BITMAP_WIDTH%
    }
}
